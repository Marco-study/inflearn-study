# 23-01-09) Stash, 취소하라 1988

## Stash란 무엇이고 왜 중요할까?

- A 브랜치에서 작업을 하다가 변겅사항이 있는데 B브랜치로 이동해야 한다면 커밋 없이는 브랜치를 이동할 수 없다.
- 이럴 때 현재 작업 중인 변경사항들을 stash를 통해 stash stack에 저장하고 브랜치를 이동할 수 있다.
- `git stash` : `modified` 영역에 있는 파일, staging area에 있는 파일을 stage stack으로 옮기는 명령어
    - working directory가 깨끗해진다.
    - `list` : stash 목록을 확인한다.
    - `apply [stash_name]` : 지정한 이름의 stash를 적용한다. 이름을 지정하지 않는다면 가장 최근의 stash가 적용된다.
        - `-index` : staged된 파일을 stash 영역으로 옮기고 다시 apply 했을 때 staged 상태로 적용하지 않는다. 이때 `-index` 옵션을 사용하면 staged 상태로 적용한다.
    - `drop` : stash 제거

## 실수를 만회하는 방법들

- 내가 수정하고자 하는 히스토리가 이미 서버에 올라갔다면 수정하면 안된다.

## 커밋전 아이들 취소하기

- `git restore` : working directory에서 변경사항을 이전으로 복구한다.
    - `--staged` : staging area에 있는 파일을 working directory로 복구한다.
    - `--source=pointer [filename]` : 해당 파일을 특정 버전 시점으로 변경한다.
        - 예를 들어, a.txt 파일이 featureA 브랜치에서 생성되었고 featureA 브랜치의 이전 브랜치가 master라면 `git restore --source=master a.txt` 명령어를 입력하면 a.txt가 remove 된다.
- `git reset [pointer]` : pointer 버전에 맞게 git을 초기화한다.

## 커밋을 수정하기

- `git --amend` : 최근 커밋 수정을 잘못해서 재수정 후 다시 커밋을 적용하고 싶을 때 사용할 수 있다.
    - `-m` : 커밋 메시지를 잘못 작성해서 변경하고 싶을 때 사용한다.

## 리셋 그리고 리셋

- 지정한 커밋을 초기화 할 수 있다.
- `git reset` : 버전 히스토리에서는 커밋을 삭제하지만 작업 내용들은 삭제하지 않고 working directory에 옮겨 놓는다.
    - `--mixed` : 기본 값이다.
    - `--soft` : 작업하고 있던 내용들이 working directory가 아니라 staging area로 옮겨진다.
    - `--hard` : 지정한 커밋 이후에 작업 내역들을 모두 삭제한다.

## 실수를 만회하는 꿀팁

- `git reflog` : 내가 HEAD에서 했던 명령어, 작업들을 로그로 기록해 놓는 것이다. 이걸 사용해서 내가 `reset`이나 특정 명령어를 사용해서 제거된 내역을 복원할 수 있다.
- `git reset [reflog_hashcode]` : 특정 작업을 했을 때 버전 상태로 돌아갈 수 있다.
    - 주의할 점은 아직 커밋이 되지 않은 상태라면 사용할 수 없다.

## 취소사항을 버전으로 남기기

- `git revert [hashcode]` : 해당 커밋에서 변경했던 내용들을 모두 삭제해주는 커밋이 생긴다.
- 이미 서버 master 브랜치에 커밋이 된 파일들은 reset, rebase보다 revert를 사용하는 것이 좋다.
    - `--no-commit` : 커밋 없이 되돌릴 수 있다.

## 깃허브의 필요성

- 다른 사람과의 협업을 위해서 서버에 파일 정보를 저장할 수 있다.
- DVC : 각각의 개발자들이 히스토리를 가지고 있음으로써 서로 공유할 수 있고 문제가 생겼을 때 복원이 가능하다.
- 서버에 저장되어 있는 깃 리포지토리를 가져오는 것 : clone
- 로컬에 커밋한 내용을 서버에 올릴 때 : push
- 서버에 업데이트된 내용을 로컬에 업데이트 하고 싶을 때 : pull

## 오픈 소스 프로젝트 참여하기

- 내 리포지토리에 특정 리포지토리를 복사하여 가져오는 것 : fork
- fork한 리포지토리에 내가 내용을 변경하여 커밋하고 원본 리포지토리에 제출하는 것 : pull request (PR)
- 승인이 된 후 오픈소스 프로젝트에 다른 변경사항이 생긴다면 rebase를 이용해서 나의 리포지토리를 오픈소스 리포지토리 버전과 맞춘 후 merge를 할 수 있다.

## 깃허브 프로젝트를 내 PC에 가지고 오기

- `git clone [repository_address]` : 원격에서 깃 리포지토리 내용을 받아옴
- `git remote` : 어떤 서버와 연결되어 있는지 확인할 수 있다.
    - `-v` : 해당 이름을 가진 서버가 어떤 주소인지 확인할 수 있다.
    - `add [name] [address]` : 해당 주소를 가진 원격 저장소를 등록한다.

## 나의 커밋을 서버에 저장하기

- `git push` : 내 로컬에서 변경사항을 연결된 원격저장소에 반영한다.

## 푸시를 간편하게 하기 SSH

- SSH 키를 사용하면 푸시할 때마다 아이디와 비밀번호를 입력하지 않아도 된다.
- 깃허브 홈페이지에서 세팅 → SSH and GPG keys를 선택해서 생성할 수 있다.

## Push 심화 내용

- Github에서 add.txt 파일을 수정한 후 커밋함
- 내 로컬은 아직 add.txt 파일을 수정하지 않은 버전임
- 내 로컬에서 add.txt 파일을 수정한 뒤 커밋 후 푸시함 → Conflict 발생
    - 원격저장소의 add.txt와 내 로컬의 add.txt의 내용이 달라 Conflict가 발생하였다.
- `git push -f` : 원격에 커밋 내용을 삭제하고 로컬의 커밋 내용을 덮어씌운다.

## 이미 만들어진 프로젝트 깃허브에 추가하기

- 내 로컬에 이미 존재하는 프로젝트를 깃 허브 리포지토리에 올리고 싶다면?
- 우선 깃허브에서 새로운 리포지토리를 만든다.
- 그리고 로컬에서 `git remote add origin [address]` 명령어를 입력한다.
- `git push`를 통해 원격저장소에 내 프로젝트의 버전 히스토리를 반영하낟.

## fetch vs pull의 차이점

- `fetch` : 원격 저장소에서 로컬 저장소보다 더 버전이 추가된 경우 해당 버전이 로컬 저장소의 버전에 추가가된다. 하지만 로컬저장소의 master는 여전히 동일한 곳을 가리키고 있다.
- `pull` : 원격 저장소에서 로컬 저장소보다 더 버전이 추가된 경우 해당 버전이 로컬 저장소의 버전에 추가가 되고 `merge`까지 한 번에 일어난다.

## pull 심화

- `fetch`는 서버에 있는 히스토리 정보를 업데이트해서 서버에서 어떤 일을 했는지 확인하고 싶은 경우 많이 사용한다.
- `pull`은 서버의 버전을 받아와서 내 로컬 버전과 동일하게 하고 싶을 때 사용한다.
- 만약, 로컬과 서버에서 동일한 파일을 수정한 뒤 각각 새로운 커밋을 만들었다면 어떻게 해결할까?
    - `git pull`을 사용한다면 conflict가 발생하고 `merge`를 이용해서 병합해줘야 한다.
        - 깃 히스토리가 더러워진다.
